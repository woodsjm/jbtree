/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.woodsjm.jbtree;

import java.math.BigDecimal;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Btree {

  public static <T extends Comparable<T>> Node<T> getParent(Node<T> root, Node<T> child) {
    if (child == null) {
      return null;
    }

    Stack<Node<T>> stack = new Stack<>();
    stack.add(root);

    while (!stack.isEmpty()) {
      Node<T> node = stack.pop();
      if (node == null) {
        continue;
      }

      if (node.getLeft() != null && node.getLeft().getVal() == child.getVal()) {
        if (child.equals(node.getLeft())) {
          return node;
        }
      }

      if (node.getRight() != null && node.getRight().getVal() == child.getVal()) {
        if (child.equals(node.getRight())) {
          return node;
        }
      }

      stack.add(node.getLeft());
      stack.add(node.getRight());
    }

    return null;
  }

  static <T extends Comparable<T>> int getIndexHelper(Node<T> root, Node<T> descendant) {
    List<Node<T>> currentNodes = new ArrayList<>();
    currentNodes.add(root);
    int currentIdx = 0;
    boolean hasMoreNodes = true;

    while (hasMoreNodes) {
      hasMoreNodes = false;
      List<Node<T>> nextNodes = new ArrayList<>();

      for (Node<T> node : currentNodes) {
        if (node == null) {
          nextNodes.add(null);
          nextNodes.add(null);
        } else {
          if (node.getVal() == descendant.getVal() && descendant.equals(node)) {
            return currentIdx;
          }

          nextNodes.add(node.getLeft());
          nextNodes.add(node.getRight());

          if (node.getLeft() != null || node.getRight() != null) {
            hasMoreNodes = true;
          }
        }

        currentIdx++;
      }

      currentNodes = nextNodes;
    }

    return -1;
  }

  public static <T extends Comparable<T>> int getIndex(Node<T> root, Node<T> descendant) {
    int result = -1;

    try {
      if (root == null) {
        throw new BtreeException.NodeTypeException("root must be a Node instance");
      }

      if (descendant == null) {
        throw new BtreeException.NodeTypeException("descendent must be a Node instance");
      }

      result = getIndexHelper(root, descendant);

      if (result == -1) {
        throw new BtreeException.NodeReferenceException("given nodes are not in the same tree");
      }
    } catch (Exception e) {
      Logger.getLogger(Btree.class.getName()).log(Level.SEVERE, "", e);
      System.exit(0);
    }

    return result;
  }

  // FIX: make tree/bst/heap float conversion internal to builder
  public static Node<Float> convertToFloat(Node<Integer> root) {
    Node<Float> clone = new Node<>(new Float(root.getVal().toString()));

    Stack<Node<Integer>> stack1 = new Stack<>();
    stack1.push(root);
    Stack<Node<Float>> stack2 = new Stack<>();
    stack2.push(clone);

    while (stack1.size() > 0 || stack2.size() > 0) {
      Node<Integer> node1 = stack1.pop();
      Node<Float> node2 = stack2.pop();

      if (node1.getLeft() != null) {
        Float floatLeft = new Float(node1.getLeft().getVal().toString());
        node2.setLeft(new Node<>(floatLeft));
        stack1.push(node1.getLeft());
        stack2.push(node2.getLeft());
      }

      if (node1.getRight() != null) {
        Float floatRight = new Float(node1.getRight().getVal().toString());
        node2.setRight(new Node<>(floatRight));
        stack1.push(node1.getRight());
        stack2.push(node2.getRight());
      }
    }

    return clone;
  }

  public static Node heap() {
    return new HeapBuilder().create();
  }

  public static Node bst() {
    return new BSTBuilder().create();
  }

  public static Node tree() {
    return new TreeBuilder().create();
  }

  public static <T extends Comparable<T>> Node build(List<T> values) {
    List<Node> nodes = new ArrayList<>(values.size());
    values.forEach(val -> nodes.add(val == null ? null : new Node(val)));

    for (int idx = 1; idx < nodes.size(); idx++) {
      if (!(nodes.get(idx) == null)) {
        int parentIdx = Math.floorDiv(idx - 1, 2);
        Node parent = nodes.get(parentIdx);

        try {
          if (parent == null) {
            throw new BtreeException.NodeNotFoundException(
                "parent node missing at index " + parentIdx);
          }
        } catch (Exception e) {
          final String message =
              "Likely a problem with the ArrayList argument\n\n"
                  + "Example A: [null, 2, 4]\n"
                  + "Fix: [1, 2, 4]\n\n"
                  + "Example B: [1, null, 4, null, 8]\n"
                  + "Fix: [1, 2, 4, null, 8]\n\n"
                  + "Here's your stack trace...";
          Logger.getLogger(Btree.class.getName()).log(Level.SEVERE, message, e);
          System.exit(0);
        }

        if (idx % 2 == 0) {
          parent.setRight(nodes.get(idx));
        } else {
          parent.setLeft(nodes.get(idx));
        }
      }
    }

    return nodes.isEmpty() ? null : nodes.get(0);
  }

  public static <T extends Comparable<T>> Node build2(List<T> values) {
    Node root = null;

    Queue<Node> queue = new ArrayDeque();

    if (!values.isEmpty()) {
      try {
        if (values.get(0) == null) {
          throw new BtreeException.NodeValueException(
              "node value must be an Integer, a Float, or a String");
        } else {
          root = new Node(values.get(0));
          queue.add(root);
        }
      } catch (Exception e) {
        Logger.getLogger(Btree.class.getName()).log(Level.SEVERE, "", e);
        System.exit(0);
      }
    }

    int idx = 1;
    while (idx < values.size()) {
      Node node = queue.remove();

      if (values.get(idx) != null) {
        node.setLeft(new Node(values.get(idx)));
        queue.add(node.getLeft());
      }

      idx++;

      if (idx < values.size() && values.get(idx) != null) {
        node.setRight(new Node(values.get(idx)));
        queue.add(node.getRight());
      }

      idx++;
    }

    return root;
  }

  static String numberToLetters(int number) {
    try {
      if (number < 0) {
        throw new AssertionError();
      }
    } catch (Error e) {
      Logger.getLogger(Btree.class.getName()).log(Level.SEVERE, "", e);
      System.exit(0);
    }

    BigDecimal bigNum = new BigDecimal(number);
    BigDecimal[] divMod = bigNum.divideAndRemainder(new BigDecimal(26));

    int quotient = divMod[0].intValue();
    int remainder = divMod[1].intValue();

    String prefix = new String(new char[quotient]).replace("\0", "Z");
    return prefix + Character.toString(65 + remainder);
  }

  static void validateTreeHeight(int height) {
    try {
      if (height < 0 || height > 9) {
        throw new BtreeException.TreeHeightException("height must be an int between 0 - 9");
      }
    } catch (Exception e) {
      Logger.getLogger(Btree.class.getName()).log(Level.SEVERE, "", e);
      System.exit(0);
    }
  }

  public static void main(String... args) {
    final String message =
        "\n"
            + "JBtree is a port of the Python library \033[3mBinarytree\033[0m.\n"
            + "It has most of Binarytree's functionality, but currently lacks support for Graphviz and Jupyter Notebooks.\n"
            + "JBtree includes matching tests.\n";

    System.out.println(message);
  }
}
