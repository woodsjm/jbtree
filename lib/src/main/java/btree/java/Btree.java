/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package btree.java;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.concurrent.ThreadLocalRandom;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.stream.IntStream;
import java.util.Stack;


public class Btree {

    private static class NodeProperties {
        int height;
        int size;
        boolean isMaxHeap;
        boolean isMinHeap;
        boolean isPerfect;
        boolean isStrict;
        boolean isComplete;
        int leafCount;
        Object minNodeValue;
        Object maxNodeValue;
        int minLeafDepth;
        int maxLeafDepth;
    
        public NodeProperties() { }
    
        public NodeProperties(
            int height, 
            int size, 
            boolean isMaxHeap, 
            boolean isMinHeap, 
            boolean isPerfect, 
            boolean isStrict, 
            boolean isComplete,
            int leafCount,
            Object minNodeValue,
            Object maxNodeValue,
            int minLeafDepth,
            int maxLeafDepth) {
                this.height = height;
                this.size = size;
                this.isMaxHeap = isMaxHeap;
                this.isMinHeap = isMinHeap;
                this.isPerfect = isPerfect;
                this.isStrict = isStrict;
                this.isComplete = isComplete;
                this.leafCount = leafCount;
                
                if (minNodeValue instanceof Integer || minNodeValue instanceof Float || minNodeValue instanceof String) {
                    this.minNodeValue = minNodeValue;
                }
                
                if (maxNodeValue instanceof Integer || maxNodeValue instanceof Float || maxNodeValue instanceof String) {
                    this.maxNodeValue = maxNodeValue;
                }
                
                this.minLeafDepth = minLeafDepth;
                this.maxLeafDepth = maxLeafDepth;
        }

        private HashMap<String, Object> toHashMap() {
            HashMap<String, Object> propsHashMap = new HashMap<>();

            propsHashMap.put("height", this.height);
            propsHashMap.put("size", this.size);
            propsHashMap.put("isMaxHeap", this.isMaxHeap);
            propsHashMap.put("isMinHeap", this.isMinHeap);
            propsHashMap.put("isPerfect", this.isPerfect);
            propsHashMap.put("isStrict", this.isStrict);
            propsHashMap.put("isComplete", this.isComplete);
            propsHashMap.put("leafCount", this.leafCount);
            propsHashMap.put("minNodeValue", this.minNodeValue);
            propsHashMap.put("maxNodeValue", this.maxNodeValue);
            propsHashMap.put("minLeafDepth", this.minLeafDepth);
            propsHashMap.put("maxLeafDepth", this.maxLeafDepth);

            return propsHashMap;
        }
    }

    public static class Node {
        private Object val;
        private Node left;
        private Node right;

        public ArrayList values = this.values();
        public HashMap<String, Object> properties = this.properties();

        // Init
        public Node(Integer value) {
            this.val = value;
        }

        public Node(String value) {
            this.val = value;
        }

        public Node(Float value) {
            this.val = value;
        }

        public Node(List<Object> list) throws BtreeException.NodeValueException {
            if (list.size() == 0) {
                throw new BtreeException.NodeValueException("node value must be an Integer, a Float, or a String");
            }
        }

        // Getters + Setters
        public Object getVal() {
            return this.val;
        }

        public void setVal(Object value) throws BtreeException.NodeValueException {
            if (value instanceof Integer || value instanceof Float || value instanceof String) {
                this.val = value;
            } else {
                throw new BtreeException.NodeValueException("node value must be an Integer, a Float, or a String");
            }
        }

        public Node getLeft() {
            return this.left;
        }

        public Node getRight() {
            return this.right;
        }

        public void setLeft(Node node) {
            this.left = node;
        }

        public void setRight(Node node) {
            this.right = node;
        }

        public Node deepCopy() {
            Node clone;
            if (this.getVal() instanceof Integer) {
                clone = new Node((Integer) this.getVal());
            } else if (this.getVal() instanceof String) {
                clone = new Node((String) this.getVal());
            } else if (this.getVal() instanceof Float) {
                clone = new Node((Float) this.getVal());
            } else {
                return null;
            }

            Stack<Node> stack1 = new Stack<>();
            stack1.push(this);
            Stack<Node> stack2 = new Stack<>();
            stack2.push(clone);
            

            while (stack1.size() > 0 || stack2.size() > 0) {
                Node node1 = stack1.pop();
                Node node2 = stack2.pop();

                if (node1.getLeft() != null) {
                    if (node1.getLeft().getVal() instanceof Integer) {
                        node2.setLeft(new Node((Integer) node1.getLeft().getVal()));
                    } else if (node1.getLeft().getVal() instanceof String) {
                        node2.setLeft(new Node((String) node1.getLeft().getVal()));
                    } else if (node1.getVal() instanceof Float) {
                        node2.setLeft(new Node((Float) node1.getLeft().getVal()));
                    }

                    stack1.push(node1.getLeft());
                    stack2.push(node2.getLeft());
                }

                if (node1.getRight() != null) {
                    if (node1.getRight().getVal() instanceof Integer) {
                        node2.setRight(new Node((Integer) node1.getRight().getVal()));
                    } else if (node1.getRight().getVal() instanceof String) {
                        node2.setRight(new Node((String) node1.getRight().getVal()));
                    } else if (node1.getVal() instanceof Float) {
                        node2.setRight(new Node((Float) node1.getRight().getVal()));
                    }

                    stack1.push(node1.getRight());
                    stack2.push(node2.getRight());
                }
            }

            return clone;
        }

        @Override
        public int hashCode() {
            return Integer.valueOf(this.getVal().toString()).intValue();
        }

        @Override
        public boolean equals(Object other) {
            if ( !(other instanceof Node) ) {
                return false;
            } else if (other == this) {
                return true;
            }
    
            Stack<Node> stack1 = new Stack<>();
            stack1.push(this);
            Stack<Node> stack2 = new Stack<>();
            stack2.push((Node) other);

            while (stack1.size() > 0 || stack2.size() > 0) {
                Node node1 = stack1.pop();
                Node node2 = stack2.pop();

                if (node1 == null && node2 == null) {
                    continue;
                } else if (node1 == null || node2 == null) {
                    return false;
                } else if (!(other instanceof Node)) {
                    return false;
                } else {
                    if (node1.getVal() instanceof Float && node2.getVal() instanceof Float) {
                        String float1 = String.format("%.2f", node1.getVal());
                        String float2 = String.format("%.2f", node2.getVal());
                        if (Float.compare(Float.valueOf(float1), Float.valueOf(float2)) != 0) {
                            return false;
                        }
                    } else if (node1.getVal() != node2.getVal()) {
                        return false;
                    }
                }
                    
                stack1.push(node1.getRight());
                stack1.push(node1.getLeft());
                stack2.push(node2.getRight());
                stack2.push(node2.getLeft());
            }

            return true;
        }

        private HashMap<String, Object> properties() {
            boolean isDescending = true;
            boolean isAscending = true;
            Object minNodeValue = this.getVal();
            Object maxNodeValue = this.getVal();
            int size = 0;
            int leafCount = 0;
            int minLeafDepth = 0;
            int maxLeafDepth = -1;
            boolean isStrict = true;
            boolean isComplete = true;
            ArrayList<Node> currentNodes = new ArrayList<>();
            currentNodes.add(this);
            boolean nonFullNodeSeen = false;

            while (currentNodes.size() > 0) {
                maxLeafDepth++;
                ArrayList<Node> nextNodes = new ArrayList<>();

                for (Node node: currentNodes) {
                    size++;
                    Object val = node.getVal();
                    // NOTE: Will be part of refactor of Node.val from Object to NodeValue
                    if (val instanceof String && minNodeValue instanceof String && maxNodeValue instanceof String) {
                        String mnv = String.valueOf(minNodeValue);
                        String mxv = String.valueOf(maxNodeValue);
                        String v = String.valueOf(val);
                        minNodeValue = mnv.compareTo(v) > 0 ? val : minNodeValue;
                        maxNodeValue = mxv.compareTo(v) < 0 ? val : maxNodeValue;
                    } else if (val instanceof Integer && minNodeValue instanceof Integer && maxNodeValue instanceof Integer) {
                        minNodeValue = Integer.valueOf((int) minNodeValue) > Integer.valueOf((int) val) ? val : minNodeValue;
                        maxNodeValue = Integer.valueOf((int) maxNodeValue) < Integer.valueOf((int) val) ? val : maxNodeValue;
                    } else if (val instanceof Float && minNodeValue instanceof Float && maxNodeValue instanceof Float) {
                        Float mnv = Float.valueOf(String.format("%.2f", minNodeValue));
                        Float mxv = Float.valueOf(String.format("%.2f", maxNodeValue));
                        Float v = Float.valueOf(String.format("%.2f", val));
                        minNodeValue = Float.compare(mnv, v) > 0 ? val : minNodeValue;
                        maxNodeValue = Float.compare(mxv, v) < 0 ? val : maxNodeValue;
                    }
                    
                    // Node is a leaf
                    if (node.getLeft() == null && node.getRight() == null) {
                        if (minLeafDepth == 0) {
                            minLeafDepth = maxLeafDepth;
                        }

                        leafCount++;
                    }

                    if (node.getLeft() != null) {
                        // FIX: Check for mismatched NodeValue types (e.g. order comparision of letters and numbers)
                        if (String.valueOf(node.getLeft().getVal()).compareTo((String) val) > 0) {
                            isDescending = false;
                        } else if (String.valueOf(node.getLeft().getVal()).compareTo((String) val) < 0) {
                            isAscending = false;
                        }

                        nextNodes.add(node.getLeft());
                        isComplete = !nonFullNodeSeen;
                    } else {
                        nonFullNodeSeen = true;
                    }

                    if (node.getRight() != null) {
                        // FIX: Check for mismatched NodeValue types (e.g. order comparision of letters and numbers)
                        if (String.valueOf(node.getRight().getVal()).compareTo((String) val) > 0) {
                            isDescending = false;
                        } else if (String.valueOf(node.getRight().getVal()).compareTo((String) val) < 0) {
                            isAscending = false;
                        }

                        nextNodes.add(node.getRight());
                        isComplete = !nonFullNodeSeen;
                    } else {
                        nonFullNodeSeen = true;
                    }

                    // If we see a node with only one child, it is not strict
                    if ((node.getLeft() == null) == (node.getRight() == null)) {
                        isStrict = false;
                    }
                }

                currentNodes = nextNodes;
            }

            // FIX: Add properties for checks of isBalanced, isBST, and isSymmetric
            return new NodeProperties(
                maxLeafDepth, // height
                size,                             
                isComplete && isDescending, // isMaxHeap
                isComplete && isAscending,  // isMinHeap
                leafCount == (1 << maxLeafDepth), //isPefect
                isStrict,
                isComplete, 
                leafCount, 
                minNodeValue,
                maxNodeValue,
                minLeafDepth,
                maxLeafDepth).toHashMap();
        }


        @Override
        public String toString() {
            String nodeString = "Node()";
            
            if (this.val instanceof Integer) {
                nodeString = String.format("Node(%d)", this.getVal());
            } else if (this.val instanceof String) {
                nodeString = String.format("Node(%s)", this.getVal());
            } else if (this.val instanceof Float) {
                nodeString = String.format("Node(%.2f)", this.getVal());
            }

            return nodeString;
        }

        private ArrayList values() {
            ArrayList<Node> currentNodes = new ArrayList<>();
            currentNodes.add(this);
            ArrayList<Object> nodeValues = new ArrayList<>();

            boolean areNodesLeft = true;
            while (areNodesLeft) {
                areNodesLeft = false;
                ArrayList<Node> nextNodes = new ArrayList<>();

                for (Node node: currentNodes) {
                    if (node == null) {
                        nodeValues.add(null);
                        nextNodes.add(null);
                        nextNodes.add(null);
                    } else {
                        if (node.getLeft() != null || node.getRight() != null) {
                            areNodesLeft = true;
                        }

                        nodeValues.add(node.getVal());
                        nextNodes.add(node.getLeft());
                        nextNodes.add(node.getRight());
                    }
                }

                currentNodes = nextNodes;
            }

            while (!nodeValues.isEmpty() && nodeValues.get(nodeValues.size() - 1) == null) {
                nodeValues.remove(nodeValues.size() - 1);
            }

            return nodeValues;
        }
    }

    public static Node tree() {
        return tree(3, false, false);
    }

    public static Node tree(int height, boolean isPerfect, boolean letters) {
        validateTreeHeight(height);
        int[] numbers = generateRandomNumbers(height);

        ArrayList<Object> values = new ArrayList<>();
        for (int num: numbers) {
            if (letters) {
                values.add((String) numberToLetters(num));
            } else {
                values.add((Integer) num);
            }
        }

        if (isPerfect) {
            try {
                return build(values);
            } catch (Exception e) {
                e.printStackTrace();
            } 
        }

        int leafCount = generateRandomLeafCount(height);
        Node root;
        if (values.get(0) instanceof String) {
            root = new Node((String) values.get(0));
        } else if (values.get(0) instanceof Integer) {
            root = new Node((Integer) values.get(0));
        } else {
            return null;
        }
        HashSet<Node> leaves = new HashSet<>();

        for (Object value: values) {
            Node node = root;
            int depth = 0;
            boolean inserted = false;

            while (depth < height && !inserted) {
                String direction = String.valueOf(ThreadLocalRandom.current().nextBoolean() ? "left" : "right");
                Node child = direction == "left" ? node.getLeft() : node.getRight();
                if (child == null) {

                    if (value instanceof String) {
                        String strVal = String.valueOf((String) value);
                        if (direction == "left") {
                            root.setLeft(new Node(strVal));
                        } else if (direction == "right") {
                            root.setRight(new Node(strVal));
                        }
                        
                    } else if (value instanceof Integer) {
                        Integer intVal = Integer.valueOf((Integer) value);
                        if (direction == "left") {
                            root.setLeft(new Node(intVal));
                        } else if (direction == "right") {
                            root.setRight(new Node(intVal));
                        }
                    }

                    inserted = true;
                }

                node = child;
                depth++;
            }

            if (inserted && depth == height) {
                leaves.add(node);
            }

            if (leaves.size() == leafCount) {
                break;
            }
        }

        return root;
    }

    private static <T> Node build(ArrayList<T> values) {
        ArrayList<Node> nodes = new ArrayList<>();
        for (T value: values) {
            if (value == null) {
                nodes.add(null);
                continue;
            } 

            if (value instanceof String) {
                nodes.add(new Node((String) value));
            } else if (value instanceof Integer) {
                nodes.add(new Node((Integer) value));
            }
        }

        for (int idx = 1; idx < nodes.size(); idx++) {
            if (!( nodes.get(idx) == null) ) {
                int parentIdx = Math.floorDiv(idx - 1, 2);
                Node parent = nodes.get(parentIdx);

                try {
                    if (parent == null) {
                        throw new BtreeException.NodeNotFoundException("parent node missing at index " + parentIdx);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } 
                
                if (idx % 2 == 0) {
                    parent.setRight(nodes.get(idx));
                } else {
                    parent.setLeft(nodes.get(idx));
                }
            }
        }

        return nodes.isEmpty() ? null : nodes.get(0);
    }

    private static int generateRandomLeafCount(int height) {
        int maxLeafCount = 1 << height;
        int halfLeafCount = Math.floorDiv(maxLeafCount, 2);

        int roll1 = ThreadLocalRandom.current().nextInt(halfLeafCount == 0 ? 1 : halfLeafCount);
        int roll2 = ThreadLocalRandom.current().nextInt(maxLeafCount - halfLeafCount);

        return roll1 + roll2 > 0 ? roll1 + roll2 : halfLeafCount;
    }

    private static int[] generateRandomNumbers(int height) {
		int maxNodeCount = (1 << (height + 1)) - 1;
		int[] nodeValues = IntStream.iterate(0, n -> n + 1).limit(maxNodeCount).toArray();

		for (int idx = 0; idx < nodeValues.length; idx++) {
			int idxToSwap = ThreadLocalRandom.current().nextInt(nodeValues.length);
			int temp = nodeValues[idxToSwap];
			nodeValues[idxToSwap] = nodeValues[idx];
			nodeValues[idx] = temp;
		}
		
	    return nodeValues;
	}

    private static String numberToLetters(int number) {
        BigDecimal bigNum = new BigDecimal(number);
        BigDecimal[] divMod = bigNum.divideAndRemainder(new BigDecimal(26));

        int quotient = divMod[0].intValue();
        int remainder = divMod[1].intValue();

        String prefix = new String(new char[quotient]).replace("\0", "Z");
        return prefix + Character.toString(65 + remainder);
    }

    private static void validateTreeHeight(int height)  {
        try {
            if (height < 0 || height > 9) {
                throw new BtreeException.TreeHeightException("height must be an int between 0 - 9");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Btree() {}

    public static void main(String... args) {
        final String message = "\n"
            + "Btree-java is a port of the (Python) Binarytree library.\n"
            + "It has most of Binarytree's functionality, but lacks support for Graphviz and Jupyter Notebooks.\n"
            + "Btree-java includes matching unit tests.\n";
        
        System.out.println(message);
    }
}


