/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package btree.java;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;
import java.util.Random;
import java.util.Stack;


public class Btree {
     
    public static class Node {
        private Object val;
        private Node left;
        private Node right;

        // Init
        public Node(Integer value) {
            this.val = value;
        }

        public Node(String value) {
            this.val = value;
        }

        public Node(Float value) {
            this.val = value;
        }

        public Node(List<Object> list) throws BtreeException.NodeValueException {
            if (list.size() == 0) {
                throw new BtreeException.NodeValueException("node value must be an Integer, a Float, or a String");
            }
        }

        // Getters + Setters
        public Object getVal() {
            return this.val;
        }

        public void setVal(Object value) throws BtreeException.NodeValueException {
            if (value instanceof Integer || value instanceof Float || value instanceof String) {
                this.val = value;
            } else {
                throw new BtreeException.NodeValueException("node value must be an Integer, a Float, or a String");
            }
        }

        public Node getLeft() {
            return this.left;
        }

        public Node getRight() {
            return this.right;
        }

        public void setLeft(Node node) {
            this.left = node;
        }

        public void setRight(Node node) {
            this.right = node;
        }

        @Override
        public int hashCode() {
            return Integer.valueOf(this.getVal().toString()).intValue();
        }

        public boolean equals(Node other) {
            Stack<Node> stack1 = new Stack<>();
            stack1.push(this);
            Stack<Node> stack2 = new Stack<>();
            stack2.push(other);

            while (stack1.size() > 0 || stack2.size() > 0) {
                Node node1 = stack1.pop();
                Node node2 = stack2.pop();

                if (node1 == null && node2 == null) {
                    continue;
                } else if (node1 == null || node2 == null) {
                    return false;
                } else if (!(other instanceof Node)) {
                    return false;
                } else {
                    if (node1.getVal() instanceof Float && node2.getVal() instanceof Float) {
                        String float1 = String.format("%.2f", node1.getVal());
                        String float2 = String.format("%.2f", node2.getVal());
                        if (Float.compare(Float.valueOf(float1), Float.valueOf(float2)) != 0) {
                            return false;
                        }
                    } else if (node1.getVal() != node2.getVal()) {
                        return false;
                    }
                }
                    
                stack1.push(node1.getRight());
                stack1.push(node1.getLeft());
                stack2.push(node2.getRight());
                stack2.push(node2.getLeft());
            }

            return true;
        }

        @Override
        public String toString() {
            String nodeString = "Node()";
            
            if (this.val instanceof Integer) {
                nodeString = String.format("Node(%d)", this.getVal());
            } else if (this.val instanceof String) {
                nodeString = String.format("Node(%s)", this.getVal());
            } else if (this.val instanceof Float) {
                nodeString = String.format("Node(%.2f)", this.getVal());
            }

            return nodeString;
        }
    }

    public static Node tree() {
        return tree(3, false, false);
    }

    public static Node tree(int height, boolean isPerfect, boolean letters) {
        validateTreeHeight(height);
        int[] numbers = generateRandomNumbers(height);

        ArrayList<Object> values = new ArrayList<>();
        for (int num: numbers) {
            if (letters) {
                values.add((String) numberToLetters(num));
            } else {
                values.add((Integer) num);
            }
        }

        if (isPerfect) {
            try {
                return build(values);
            } catch (Exception e) {
                e.printStackTrace();
            } 
        }

        return null;
    }

    private static <T> Node build(ArrayList<T> values) {
        ArrayList<Node> nodes = new ArrayList<>();
        for (T value: values) {
            if (value == null) {
                nodes.add(null);
                continue;
            } 

            if (value instanceof String) {
                nodes.add(new Node((String) value));
            } else if (value instanceof Integer) {
                nodes.add(new Node((Integer) value));
            }
        }

        for (int idx = 1; idx < nodes.size(); idx++) {
            if (!( nodes.get(idx) == null) ) {
                int parentIdx = Math.floorDiv(idx - 1, 2);
                Node parent = nodes.get(parentIdx);

                try {
                    if (parent == null) {
                        throw new BtreeException.NodeNotFoundException("parent node missing at index " + parentIdx);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } 
                
                if (idx % 2 == 0) {
                    parent.setRight(nodes.get(idx));
                } else {
                    parent.setLeft(nodes.get(idx));
                }
            }
        }

        return nodes.isEmpty() ? null : nodes.get(0);
    }

    private static int[] generateRandomNumbers(int height) {
		int maxNodeCount = (1 << (height + 1)) - 1;
		int[] nodeValues = IntStream.iterate(0, n -> n + 1).limit(maxNodeCount).toArray();

		Random rand = new Random();
		for (int idx = 0; idx < nodeValues.length; idx++) {
			int idxToSwap = rand.nextInt(nodeValues.length);
			int temp = nodeValues[idxToSwap];
			nodeValues[idxToSwap] = nodeValues[idx];
			nodeValues[idx] = temp;
		}
		
	    return nodeValues;
	}

    private static String numberToLetters(int number) {
        BigDecimal bigNum = new BigDecimal(number);
        BigDecimal[] divMod = bigNum.divideAndRemainder(new BigDecimal(26));

        int quotient = divMod[0].intValue();
        int remainder = divMod[1].intValue();

        String prefix = new String(new char[quotient]).replace("\0", "Z");
        return prefix + Character.toString(65 + remainder);
    }

    private static void validateTreeHeight(int height)  {
        try {
            if (height < 0 || height > 9) {
                throw new BtreeException.TreeHeightException("height must be an int between 0 - 9");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Btree() {}

    public static void main(String... args) {
        final String message = "\n"
            + "Btree-java is a port of the (Python) Binarytree library.\n"
            + "It has most of Binarytree's functionality, but lacks support for Graphviz and Jupyter Notebooks.\n"
            + "Btree-java includes matching unit tests.\n";
        
        System.out.println(message);
    }
}


